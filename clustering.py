"""Photo Clusters - Affinity Propagation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CnZL4OOJtP9mRwTG2wTtab6jdFFP4fFI
"""

# Authors: The scikit-learn developers
# SPDX-License-Identifier: BSD-3-Clause

import matplotlib.patheffects as PathEffects
import matplotlib.pyplot as plt
import numpy as np

from sklearn import metrics
from sklearn.cluster import AffinityPropagation
from sklearn.metrics.pairwise import pairwise_distances

from geopy.distance import geodesic

import pandas as pd

import pymongo 

import os
from dotenv import load_dotenv

load_dotenv()

MONGO_HOST = os.getenv('MONGO_HOST', 'localhost')
MONGO_PORT = int(os.getenv('MONGO_PORT', 27017))
MONGO_DATABASE = os.getenv('MONGO_DATABASE', 'photoLocator')
TEMP_IMAGE_FILE = os.getenv('TEMP_IMAGE_FILE') 

myclient = pymongo.MongoClient(MONGO_HOST,MONGO_PORT)
db = myclient[MONGO_DATABASE]
photos = db["photos"]

query = {"$and": [{"GPSPosition": {"$ne": None}}, {"GPSAltitude": {"$ne": None}}]}
datapoints = list(photos.find(query))

#df = pd.json_normalize(datapoints)
df = pd.read_csv(TEMP_IMAGE_FILE)

df[df.columns[1:3]]

coords = df[df.columns[1:3]].values
print(coords)

def geodesic_wrapper(point1, point2):
    """Wrapper for geopy.distance.geodesic to work with pairwise_distances."""
    # geopy expects (latitude, longitude) tuples
    return geodesic(point1, point2).km # Access the distance in kilometers

print("Calculating pairwise Geodesic distances...")
# Note: Geodesic calculation can be slower than Haversine for large datasets.
distance_matrix = pairwise_distances(coords, metric=geodesic_wrapper)

similarity_matrix = -distance_matrix

"""
=================================================
Demo of affinity propagation clustering algorithm
=================================================

Reference:
Brendan J. Frey and Delbert Dueck, "Clustering by Passing Messages
Between Data Points", Science Feb. 2007

"""

X = df[df.columns[1:3]]

# %%
# Compute Affinity Propagation
# ----------------------------
af = AffinityPropagation(affinity='precomputed',
                              damping=0.9,        # Adjust damping if convergence issues occur
                              max_iter = 500,
                              random_state=42)   # For reproducible results
af.fit(similarity_matrix)

cluster_centers_indices = af.cluster_centers_indices_
labels = af.labels_

n_clusters_ = len(cluster_centers_indices)

print("Estimated number of clusters: %d" % n_clusters_)
print("Homogeneity: %0.3f" % metrics.homogeneity_score(labels, labels))
print("Completeness: %0.3f" % metrics.completeness_score(labels, labels))
print("V-measure: %0.3f" % metrics.v_measure_score(labels, labels))
print("Adjusted Rand Index: %0.3f"
       % metrics.adjusted_rand_score(labels, labels))

# Add cluster labels back to the original DataFrame (optional)
df['cluster_id'] = labels
centers = []

if cluster_centers_indices is not None and len(cluster_centers_indices) > 0:
    n_clusters_ = len(cluster_centers_indices)
    print(f"\nEstimated number of clusters: {n_clusters_}")

    # Print details for each cluster
    for cluster_id in range(n_clusters_):
        # Get the index (in the original DataFrame/coords_array) of the point that is the cluster center (exemplar)
        center_index = cluster_centers_indices[cluster_id]
        # Get the details of the center point from the DataFrame
        center_point_details = df.iloc[center_index]
        
        # Update all photos in this cluster
        cluster_members_indices = np.where(labels == cluster_id)[0]
        for member_index in cluster_members_indices:
            member_details = df.iloc[member_index]
            photos.update_one(
                {"SourceFile": member_details['SourceFile']},
                {
                    "$set": {
                        "cluster": {
                            "id": cluster_id,
                            "isCenter": False,
                            "locationName": None  # Will be updated by reverse geocoding
                        }
                    }
                }
            )
        # Update the center photo
        photos.update_one(
            {"SourceFile": center_point_details['SourceFile']},
            {
                "$set": {
                    "cluster": {
                        "id": cluster_id,
                        "isCenter": True,
                        "locationName": None  # Will be updated by reverse geocoding
                    }
                }
            }
        )

        centers.append({
            'latitude': float(center_point_details['GPSLatitude']),
            'longitude': float(center_point_details['GPSLongitude']),
            'cluster_id': cluster_id
        })

elif hasattr(af, 'labels_') and len(np.unique(af.labels_)) > 0:
    # Handle cases where fit converges but cluster_centers_indices_ might be empty/None
    labels = af.labels_
    unique_labels = np.unique(labels)
    n_clusters_ = len(unique_labels)
    print(f"\nAffinity Propagation converged, but cluster centers might be ambiguous.")
    print(f"Estimated number of clusters based on labels: {n_clusters_}")

    for cluster_id in unique_labels:
        cluster_members_indices = np.where(labels == cluster_id)[0]
        cluster_members_details = df.iloc[cluster_members_indices]
        print(f"\n--- Cluster {cluster_id} ---")
        print(f"  Number of members: {len(cluster_members_indices)}")
        print("  Members (Index -> [Lat, Lon] (Name)):")
        #for index, member in cluster_members_details.iterrows():
           #  print(f"    - Index {index} -> {member[['latitude', 'longitude']].tolist()} (Name: {member.get('location_name', 'N/A')})")

else:
    print("\nAffinity Propagation did not converge or found no clusters.")
    if hasattr(af, 'n_iter_'):
      print(f"Number of iterations: {af.n_iter_}")

#print("\nDataFrame with cluster assignments:\n", df)
print("\nScript finished.")

df.plot.scatter(x = 'GPSLongitude', y = 'GPSLatitude', c=labels, s=50, cmap='viridis')
#plt.scatter(centers[:, 0], centers[:, 1], c='black', s=200, alpha=0.5)
